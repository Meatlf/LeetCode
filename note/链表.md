# 链表

在LeetCode中,链表默认没有head结点.

## 特性

### 面试被提及最频繁的数据结构

### 链表的数据结构很灵活

### 用指针进行操作

### 动态数据结构：表现为创建链表时，无须知道链表的长度

### 由于是动态分配内存，没有闲置内存，因而链表的空间效率比数组高

## 节点定义

### struct ListNode { int iVal, ListNode* pNext; ListNode(int x): iVal(x), pNext(NULL){}

## 基本操作

### 创建链表

- 通过动态分配内存生成节点：malloc( )
- 创建的节点均为指针类型
- 创建首节点pHeadNode
- 创建尾节点pTailNode，此时尾节点地址与首节点地址相同
- 通过流输入整数，将插入的节点值赋为整数，该整数为0时整个插入节点的工作结束
- 在尾节点之后插入新的节点，尾节点并向后移动一个节点
- 特别要注意：头节点需要初始化

### 打印链表

- 不要打印首节点

### 判断是否为空链表

- 判断头节点是否指向NULL

## LeetCode

### 206.反转链表

参考资料: [动画演示+多种解法 206. 反转链表](https://leetcode-cn.com/problems/reverse-linked-list/solution/dong-hua-yan-shi-206-fan-zhuan-lian-biao-by-user74/)

**迭代法**:迭代法基于**双指针迭代**.

## 题库

### 面35 复杂链表的复制

### 面62 圆圈中最后剩下的数字

### 面25 合并两个排序的链表

### 面18 删除聊表的节点

### 面6 从尾到头打印链表

### 面22 链表中倒数第k个节点

### 

### 面52 两个链表的第一个公共节点

### 面36 二叉搜索树与双向链表

## 策略

### 快慢指针

*XMind: ZEN - Trial Version*